from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import ContextTypes
from telegram.constants import ParseMode
from config import CHAT_MODES, AVAILABLE_LANGUAGES, AVAILABLE_MODELS, CREDIT_COSTS
from utils.translations import get_text
from database.credits_client import get_user_credits

# Funkcje pomocnicze

def get_user_language(context, user_id):
    """
    Pobiera jƒôzyk u≈ºytkownika z kontekstu lub bazy danych
    
    Args:
        context: Kontekst bota
        user_id: ID u≈ºytkownika
        
    Returns:
        str: Kod jƒôzyka (pl, en, ru)
    """
    # Sprawd≈∫, czy jƒôzyk jest zapisany w kontek≈õcie
    if 'user_data' in context.chat_data and user_id in context.chat_data['user_data'] and 'language' in context.chat_data['user_data'][user_id]:
        return context.chat_data['user_data'][user_id]['language']
    
    # Je≈õli nie, pobierz z bazy danych
    try:
        from database.sqlite_client import sqlite3, DB_PATH
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute("SELECT language FROM users WHERE id = ?", (user_id,))
        result = cursor.fetchone()
        conn.close()
        
        if result and result[0]:
            # Zapisz w kontek≈õcie na przysz≈Ço≈õƒá
            if 'user_data' not in context.chat_data:
                context.chat_data['user_data'] = {}
            
            if user_id not in context.chat_data['user_data']:
                context.chat_data['user_data'][user_id] = {}
            
            context.chat_data['user_data'][user_id]['language'] = result[0]
            return result[0]
    except Exception as e:
        print(f"B≈ÇƒÖd pobierania jƒôzyka z bazy: {e}")
    
    # Domy≈õlny jƒôzyk, je≈õli nie znaleziono w bazie
    return "pl"

def get_user_current_mode(context, user_id):
    """Pobiera aktualny tryb czatu u≈ºytkownika"""
    if 'user_data' in context.chat_data and user_id in context.chat_data['user_data']:
        user_data = context.chat_data['user_data'][user_id]
        if 'current_mode' in user_data and user_data['current_mode'] in CHAT_MODES:
            return user_data['current_mode']
    return "no_mode"

def get_user_current_model(context, user_id):
    """Pobiera aktualny model AI u≈ºytkownika"""
    if 'user_data' in context.chat_data and user_id in context.chat_data['user_data']:
        user_data = context.chat_data['user_data'][user_id]
        if 'current_model' in user_data and user_data['current_model'] in AVAILABLE_MODELS:
            return user_data['current_model']
    return "gpt-3.5-turbo"  # Domy≈õlny model

def store_menu_state(context, user_id, state, message_id=None):
    """
    Zapisuje stan menu dla u≈ºytkownika
    
    Args:
        context: Kontekst bota
        user_id: ID u≈ºytkownika
        state: Stan menu (np. 'main', 'settings', 'chat_modes')
        message_id: ID wiadomo≈õci menu (opcjonalnie)
    """
    if 'user_data' not in context.chat_data:
        context.chat_data['user_data'] = {}
    
    if user_id not in context.chat_data['user_data']:
        context.chat_data['user_data'][user_id] = {}
    
    context.chat_data['user_data'][user_id]['menu_state'] = state
    
    if message_id:
        context.chat_data['user_data'][user_id]['menu_message_id'] = message_id

def get_menu_state(context, user_id):
    """
    Pobiera stan menu dla u≈ºytkownika
    
    Args:
        context: Kontekst bota
        user_id: ID u≈ºytkownika
        
    Returns:
        str: Stan menu lub 'main' je≈õli brak
    """
    if 'user_data' in context.chat_data and user_id in context.chat_data['user_data'] and 'menu_state' in context.chat_data['user_data'][user_id]:
        return context.chat_data['user_data'][user_id]['menu_state']
    return 'main'

def get_menu_message_id(context, user_id):
    """
    Pobiera ID wiadomo≈õci menu dla u≈ºytkownika
    
    Args:
        context: Kontekst bota
        user_id: ID u≈ºytkownika
        
    Returns:
        int: ID wiadomo≈õci lub None je≈õli brak
    """
    if 'user_data' in context.chat_data and user_id in context.chat_data['user_data'] and 'menu_message_id' in context.chat_data['user_data'][user_id]:
        return context.chat_data['user_data'][user_id]['menu_message_id']
    return None

# Funkcje generujƒÖce menu

def create_main_menu_markup(language):
    """
    Tworzy klawiaturƒô dla g≈Ç√≥wnego menu
    """
    keyboard = [
        [
            InlineKeyboardButton(get_text("menu_chat_mode", language), callback_data="menu_section_chat_modes"),
            InlineKeyboardButton(get_text("image_generate", language), callback_data="menu_image_generate")
        ],
        [
            InlineKeyboardButton(get_text("menu_credits", language), callback_data="menu_section_credits"),
            InlineKeyboardButton(get_text("menu_dialog_history", language), callback_data="menu_section_history")
        ],
        [
            InlineKeyboardButton(get_text("menu_settings", language), callback_data="menu_section_settings"),
            InlineKeyboardButton(get_text("menu_help", language), callback_data="menu_help")
        ]
    ]
    
    return InlineKeyboardMarkup(keyboard)

# ... [pozosta≈Çe funkcje create_*_menu_markup]

# Funkcje obs≈ÇugujƒÖce menu

async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Wy≈õwietla g≈Ç√≥wne menu bota z przyciskami inline
    """
    user_id = update.effective_user.id
    
    # Upewnij siƒô, ≈ºe klawiatura systemowa jest usuniƒôta
    await update.message.reply_text("Usuwam klawiaturƒô...", reply_markup=ReplyKeyboardRemove())
    
    # Pobierz jƒôzyk u≈ºytkownika
    language = get_user_language(context, user_id)
    
    # Pobierz informacje o statusie u≈ºytkownika
    credits = get_user_credits(user_id)
    current_mode = get_user_current_mode(context, user_id)
    current_model = get_user_current_model(context, user_id)
    
    # Przygotuj informacje o aktualnym trybie i modelu
    mode_name = CHAT_MODES[current_mode]["name"] if current_mode in CHAT_MODES else "Standard"
    model_name = AVAILABLE_MODELS[current_model] if current_model in AVAILABLE_MODELS else "GPT-3.5"
    
    # Przygotuj tekst statusu
    status_text = f"""*{get_text("main_menu", language)}*

*{get_text("status", language)}:*
{get_text("credits", language)}: *{credits}*
{get_text("current_mode", language)}: *{mode_name}*
{get_text("current_model", language)}: *{model_name}*

{get_text("select_option", language, default="Wybierz opcjƒô z menu poni≈ºej:")}"""
    
    # Utw√≥rz klawiaturƒô menu
    reply_markup = create_main_menu_markup(language)
    
    # Wy≈õlij menu
    message = await update.message.reply_text(
        status_text,
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN
    )
    
    # Zapisz ID wiadomo≈õci menu i stan menu
    store_menu_state(context, user_id, 'main', message.message_id)

async def update_menu(update: Update, context: ContextTypes.DEFAULT_TYPE, menu_state, markup=None):
    """
    Aktualizuje istniejƒÖce menu
    
    Args:
        update: Obiekt Update
        context: Kontekst bota
        menu_state: Nowy stan menu
        markup: Klawiatura menu (opcjonalnie)
    """
    query = update.callback_query
    user_id = query.from_user.id
    language = get_user_language(context, user_id)
    
    # Pobierz informacje o statusie u≈ºytkownika
    credits = get_user_credits(user_id)
    current_mode = get_user_current_mode(context, user_id)
    current_model = get_user_current_model(context, user_id)
    
    # Przygotuj informacje o aktualnym trybie i modelu
    mode_name = CHAT_MODES[current_mode]["name"] if current_mode in CHAT_MODES else "Standard"
    model_name = AVAILABLE_MODELS[current_model] if current_model in AVAILABLE_MODELS else "GPT-3.5"
    
    # Utw√≥rz tekst menu na podstawie stanu
    if menu_state == 'main':
        menu_title = get_text("main_menu", language)
        menu_text = f"""üìã *{menu_title}*

*{get_text("status", language, default="Status")}:*
üí∞ {get_text("credits", language)}: *{credits}*
üí¨ {get_text("current_mode", language, default="Aktualny tryb")}: *{mode_name}*
ü§ñ {get_text("current_model", language, default="Model")}: *{model_name}*

{get_text("select_option", language, default="Wybierz opcjƒô z menu poni≈ºej:")}"""
        if not markup:
            markup = create_main_menu_markup(language)
    
    # ... [pozosta≈Çe stany menu - zachowaj istniejƒÖcƒÖ implementacjƒô]
    
    # Aktualizuj wiadomo≈õƒá menu
    await query.edit_message_text(
        text=menu_text,
        reply_markup=markup,
        parse_mode=ParseMode.MARKDOWN
    )
    
    # Zapisz nowy stan menu
    store_menu_state(context, user_id, menu_state)

async def handle_contextual_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Obs≈Çuguje callbacki zwiƒÖzane z opcjami menu kontekstowego
    
    Returns:
        bool: True je≈õli callback zosta≈Ç obs≈Çu≈ºony, False w przeciwnym razie
    """
    query = update.callback_query
    
    # Sprawd≈∫, czy to callback menu kontekstowego
    if not query.data.startswith("context_"):
        return False
    
    user_id = query.from_user.id
    language = get_user_language(context, user_id)
    
    await query.answer()  # Odpowied≈∫, aby usunƒÖƒá zegar oczekiwania
    
    # Obs≈Çuga r√≥≈ºnych opcji menu kontekstowego
    if query.data == "context_generate_image":
        # Pobierz oryginalny tekst wiadomo≈õci jako prompt
        original_message = query.message.reply_to_message.text
        await query.edit_message_text(
            get_text("generating_image", language)
        )
        
        # Wywo≈Çaj funkcjƒô generowania obrazu z oryginalnƒÖ wiadomo≈õciƒÖ jako promptem
        from handlers.image_handler import generate_image_dall_e
        image_url = await generate_image_dall_e(original_message)
        
        # Odejmij kredyty
        from database.credits_client import deduct_user_credits
        deduct_user_credits(user_id, 10, "Generowanie obrazu przez menu kontekstowe")
        
        if image_url:
            await context.bot.send_photo(
                chat_id=query.message.chat_id,
                photo=image_url,
                caption=f"*{get_text('generated_image', language)}*\n{original_message}",
                parse_mode=ParseMode.MARKDOWN
            )
            await query.message.delete()  # Usu≈Ñ wiadomo≈õƒá menu
        else:
            await query.edit_message_text(
                get_text("image_generation_error", language)
            )
        return True
        
    elif query.data == "context_code_mode":
        # Prze≈ÇƒÖcz na tryb programisty
        if 'user_data' not in context.chat_data:
            context.chat_data['user_data'] = {}
        
        if user_id not in context.chat_data['user_data']:
            context.chat_data['user_data'][user_id] = {}
        
        context.chat_data['user_data'][user_id]['current_mode'] = "code_developer"
        
        await query.edit_message_text(
            f"{get_text('switched_to_mode', language)} *{CHAT_MODES['code_developer']['name']}*\n\n"
            f"{get_text('ask_coding_question', language)}",
            parse_mode=ParseMode.MARKDOWN
        )
        return True
        
    elif query.data == "context_detailed":
        # ≈ªƒÖdanie szczeg√≥≈Çowego wyja≈õnienia oryginalnej wiadomo≈õci
        original_message = query.message.reply_to_message.text
        
        await query.edit_message_text(
            get_text("detailed_explanation_requested", language)
        )
        
        # Przygotuj prompt z ≈ºƒÖdaniem szczeg√≥≈Çowego wyja≈õnienia
        prompt = f"Proszƒô o szczeg√≥≈Çowe wyja≈õnienie nastƒôpujƒÖcego zagadnienia: {original_message}"
        
        # Utw√≥rz nowƒÖ wiadomo≈õƒá z ≈ºƒÖdaniem szczeg√≥≈Çowego wyja≈õnienia
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            text=prompt
        )
        return True
        
    elif query.data == "context_hide":
        # Ukryj menu kontekstowe
        await query.message.delete()
        return True
    
    return False

# ZastƒÖp funkcjƒô handle_menu_callback w pliku handlers/menu_handler.py poni≈ºszym kodem

async def handle_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Obs≈Çuguje wszystkie callbacki zwiƒÖzane z menu
    
    Returns:
        bool: True je≈õli callback zosta≈Ç obs≈Çu≈ºony, False w przeciwnym razie
    """
    query = update.callback_query
    
    # Debugowanie
    print(f"Menu handler otrzyma≈Ç callback: {query.data}")
    
    # Sprawd≈∫, czy to callback zwiƒÖzany z menu
    if not query.data.startswith("menu_"):
        return False
    
    user_id = query.from_user.id
    language = get_user_language(context, user_id)
    
    # Obs≈Çuga przycisk√≥w menu
    if query.data == "menu_section_chat_modes":
        # Utworzenie menu tryb√≥w czatu
        keyboard = []
        for mode_id, mode_info in CHAT_MODES.items():
            keyboard.append([
                InlineKeyboardButton(
                    mode_info['name'], 
                    callback_data=f"mode_{mode_id}"
                )
            ])
        
        # Dodaj przycisk powrotu
        keyboard.append([
            InlineKeyboardButton("Powr√≥t", callback_data="menu_back_main")
        ])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "Wybierz tryb czatu:",
            reply_markup=reply_markup
        )
        return True
        
    elif query.data == "menu_section_credits":
        # Menu kredyt√≥w
        keyboard = [
            [InlineKeyboardButton("Sprawd≈∫ saldo", callback_data="credits_check")],
            [InlineKeyboardButton("Kup kredyty", callback_data="credits_buy")],
            [InlineKeyboardButton("Powr√≥t", callback_data="menu_back_main")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            f"Kredyty: {get_user_credits(user_id)}\nWybierz opcjƒô:",
            reply_markup=reply_markup
        )
        return True
        
    elif query.data == "menu_image_generate":
        # Menu generowania obraz√≥w
        keyboard = [
            [InlineKeyboardButton("Powr√≥t", callback_data="menu_back_main")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "Aby wygenerowaƒá obraz, u≈ºyj komendy:\n/image [opis obrazu]",
            reply_markup=reply_markup
        )
        return True
        
    elif query.data == "menu_section_history":
        # Menu historii
        keyboard = [
            [InlineKeyboardButton("Nowa konwersacja", callback_data="history_new")],
            [InlineKeyboardButton("Eksportuj", callback_data="history_export")],
            [InlineKeyboardButton("Powr√≥t", callback_data="menu_back_main")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "Historia rozm√≥w - wybierz opcjƒô:",
            reply_markup=reply_markup
        )
        return True
        
    elif query.data == "menu_section_settings":
        # Menu ustawie≈Ñ
        keyboard = [
            [InlineKeyboardButton("Zmie≈Ñ model AI", callback_data="settings_model")],
            [InlineKeyboardButton("Zmie≈Ñ jƒôzyk", callback_data="settings_language")],
            [InlineKeyboardButton("Powr√≥t", callback_data="menu_back_main")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "Ustawienia - wybierz opcjƒô:",
            reply_markup=reply_markup
        )
        return True
        
    elif query.data == "menu_help":
        # Menu pomocy
        keyboard = [
            [InlineKeyboardButton("Powr√≥t", callback_data="menu_back_main")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "Pomoc:\n\n/start - Start\n/credits - Sprawd≈∫ kredyty\n/buy - Kup kredyty\n/image - Generuj obraz",
            reply_markup=reply_markup
        )
        return True
        
    elif query.data == "menu_back_main":
        # Powr√≥t do g≈Ç√≥wnego menu
        keyboard = [
            [
                InlineKeyboardButton("üîÑ Tryb czatu", callback_data="menu_section_chat_modes"),
                InlineKeyboardButton("üñºÔ∏è Generuj obraz", callback_data="menu_image_generate")
            ],
            [
                InlineKeyboardButton("üí∞ Kredyty", callback_data="menu_section_credits"),
                InlineKeyboardButton("üìÇ Historia", callback_data="menu_section_history")
            ],
            [
                InlineKeyboardButton("‚öôÔ∏è Ustawienia", callback_data="menu_section_settings"),
                InlineKeyboardButton("‚ùì Pomoc", callback_data="menu_help")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            f"Menu g≈Ç√≥wne\n\nStatus:\nKredyty: {get_user_credits(user_id)}\nWybierz opcjƒô z menu poni≈ºej:",
            reply_markup=reply_markup
        )
        return True
    
    print(f"Nieobs≈Çu≈ºony callback menu: {query.data}")
    return False

# Funkcja do wy≈õwietlania menu kontekstowego po wiadomo≈õci u≈ºytkownika
async def show_contextual_menu(update: Update, context: ContextTypes.DEFAULT_TYPE, user_message):
    """
    Wy≈õwietla menu kontekstowe na podstawie tre≈õci wiadomo≈õci u≈ºytkownika
    
    Args:
        update: Obiekt Update
        context: Kontekst bota
        user_message: Tre≈õƒá wiadomo≈õci u≈ºytkownika
        
    Returns:
        bool: True je≈õli menu zosta≈Ço wy≈õwietlone, False w przeciwnym razie
    """
    user_id = update.effective_user.id
    
    # Sprawd≈∫, czy u≈ºytkownik ma w≈ÇƒÖczone menu kontekstowe
    # (mo≈ºna dodaƒá opcjƒô wy≈ÇƒÖczenia w ustawieniach)
    context_enabled = True
    
    if not context_enabled:
        return False
    
    # Wygeneruj menu kontekstowe
    markup = create_contextual_menu_markup(context, user_id, user_message)
    
    if markup:
        # Wy≈õlij menu kontekstowe jako odpowied≈∫ na wiadomo≈õƒá u≈ºytkownika
        language = get_user_language(context, user_id)
        
        await update.message.reply_text(
            get_text("contextual_options", language, default="Opcje kontekstowe:"),
            reply_markup=markup,
            reply_to_message_id=update.message.message_id
        )
        return True
    
    return False

async def set_user_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Ustawia niestandardowƒÖ nazwƒô u≈ºytkownika
    U≈ºycie: /setname [nazwa]
    """
    user_id = update.effective_user.id
    language = get_user_language(context, user_id)
    
    # Sprawd≈∫, czy podano nazwƒô
    if not context.args or len(' '.join(context.args)) < 1:
        await update.message.reply_text(get_text("settings_change_name", language))
        return
    
    name = ' '.join(context.args)
    
    # Zapisz nazwƒô w kontek≈õcie u≈ºytkownika
    if 'user_data' not in context.chat_data:
        context.chat_data['user_data'] = {}
    
    if user_id not in context.chat_data['user_data']:
        context.chat_data['user_data'][user_id] = {}
    
    context.chat_data['user_data'][user_id]['custom_name'] = name
    
    # Wy≈õlij potwierdzenie z przyciskiem menu
    keyboard = [[InlineKeyboardButton("üìã " + get_text("menu", language, default="Menu"), callback_data="menu_back_main")]]
    
    await update.message.reply_text(
        f"{get_text('name_changed', language, default='Twoja nazwa zosta≈Ça zmieniona na')}: *{name}*",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode=ParseMode.MARKDOWN
    )